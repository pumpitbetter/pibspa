# Pump It Better - Configuration and Standards

## Project Overview

PumpItBetter i#### Migration Status

**Completed**:

- ✅ Updated templates schema to require array format for increment/decrement
- ✅ Converted all template files to use array format
- ✅ Removed legacy single-object progression support
- ✅ Created helper functions for array-based progression logic
- ✅ Updated route files to use helper functions
- ✅ Implemented realistic deloading logic
- ✅ Added history-based rep progression helper functions
- ✅ Unified all progression into single algorithm
- ✅ Removed progression type checking from code
- ✅ Updated templates to remove type field from progression
- ✅ Fixed TypeScript compilation issues

**Pending**:

- [ ] Test unified progression workflow end-to-end
- [ ] Add deloading logic for failed attempts
- [ ] Consider adding rep progression visualization in the UIng app built with React Router v7, Vite, and RxDB. It features a comprehensive exercise database, multiple training programs, and progression tracking.

## Development Standards

### Utility Scripts

- **Location**: Use `/tmp` for all temporary utility scripts
- **Cleanup**: Always delete temp scripts after use (`rm /tmp/script-name.js`)
- **Rationale**: Keeps the codebase clean and prevents accumulation of one-off scripts

### Unified Progression System

The app uses a **unified double progression system** that handles all progression types through a single algorithm. This approach simplifies configuration and code maintenance while maintaining full flexibility.

#### How It Works

**All exercises use the same progression logic**:

- If current reps < max reps → progress reps
- If current reps = max reps → progress weight, reset to min reps

**Configuration Examples**:

**Linear Progression** (weight only):

```typescript
{
  repRange: { min: 5, max: 5 }, // Same min/max = no rep progression
  progression: {
    increment: [{ kind: 'weight', value: 5 }]
  }
}
```

**Double Progression** (reps then weight):

```typescript
{
  repRange: { min: 5, max: 8 }, // Rep range allows progression
  progression: {
    increment: [
      { kind: 'reps', value: 1 },
      { kind: 'weight', value: 5 }
    ]
  }
}
```

**Rep-Only Progression** (bodyweight exercises):

```typescript
{
  repRange: { min: 8, max: 15 }, // Wide rep range
  progression: {
    increment: [
      { kind: 'reps', value: 1 },
      { kind: 'weight', value: 0 } // No weight progression
    ]
  }
}
```

#### Benefits of Unified Approach

1. **Simplified Code**: Single progression algorithm handles all cases
2. **Flexible Configuration**: Any progression pattern through `repRange` settings
3. **Backward Compatible**: Existing linear progression works by setting `min = max`
4. **Consistent Logic**: No need for type checking or separate code paths
5. **Easy to Understand**: One system to learn and maintain

#### History-Based Rep Progression

**Architecture Decision**: Use history-based rep progression instead of storing current reps in the program schema.

**Benefits**:

- Programs remain lightweight (only track weight)
- Complete progression history is maintained
- More accurate progression based on actual performance
- Supports complex progression rules and conditions

**Helper Functions**:

- `getCurrentReps()`: Calculates target reps based on history and rep range
- `getLastExerciseHistory()`: Retrieves most recent completed set for an exercise

**Completed**:

- ✅ Updated templates schema to require array format for increment/decrement
- ✅ Converted all template files to use array format
- ✅ Removed legacy single-object progression support
- ✅ Created helper functions for array-based progression logic
- ✅ Updated route files to use helper functions
- ✅ Implemented realistic deloading logic
- ✅ Added history-based rep progression helper functions
- ✅ Updated queue route to calculate target reps based on history for double progression
- ✅ Added progression type field and rep range support to templates
- ✅ Updated workout completion logic to handle double progression
- ✅ Fixed TypeScript compilation issues with template creation

**Pending**:

- [ ] Add more double progression exercises to templates
- [ ] Test double progression workflow end-to-end
- [ ] Add deloading logic for failed attempts
- [ ] Consider adding rep progression visualization in the UI

### Database Schema Changes

**Templates** (`app/db/templates.ts`):

- `increment` and `decrement` are now always arrays of progression rules
- Each rule has `kind`, `value`, and optional `condition` properties

**Sets** (`app/db/sets.ts`):

- Removed legacy support for single increment/decrement objects
- All progression rules use array format consistently

**History** (`app/db/history.ts`):

- Already supports `targetReps` and `liftedReps` for tracking progression
- Used as source of truth for calculating current rep targets

### Deloading Logic

**Realistic Deloading Values**:

- Heavy leg exercises (squat, deadlift): 10 lbs
- Upper body compound: 5 lbs
- Accessories: 2.5 lbs

**Double Progression Deloading**:

1. First attempt: Reduce reps by 1 (if above minimum)
2. If at minimum reps: Reduce weight by appropriate amount
3. Reset to minimum reps when weight is reduced

### File Organization

**Core Files**:

- `app/db/templates-*.ts`: Program templates with progression rules
- `app/lib/progression-helpers.ts`: Progression calculation utilities
- `app/routes/app_.workouts_.$workoutId/route.tsx`: Workout completion logic
- `app/routes/app.queue/route.tsx`: Workout generation with target calculation

**Template Files**:
All template files now use consistent array-based progression format.

## Recent Changes

### 2024-01-XX: Double Progression Implementation

- Implemented history-based rep progression for double progression exercises
- Updated queue route to calculate target reps based on workout history
- Added double progression handler in workout completion logic
- Fixed TypeScript issues with template array format requirements
- Ensured all template creation uses consistent array-based progression format

### Code Quality Standards

- All TypeScript compilation must be error-free
- Use helper functions for progression logic rather than inline calculations
- Document complex progression rules with comments
- Test progression logic with realistic scenarios
